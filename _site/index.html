<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Anton Davydov &middot; Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/base.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- SEO -->
  

  <link rel="author" href="https://plus.google.com/u/0/104253015484296728880"/>
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Simple blog where I'll write about ruby, my ideas and technologies which I love<br><a href="https://twitter.com/anton_davydov" target="_blank">@anton_davydov</a></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/davydovanton">GitHub</a>
    <a class="sidebar-nav-item" href="https://twitter.com/anton_davydov">Twitter</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2015. All rights reserved.
    </p>
  </div>
</div>

    <div class="yandex_metrica">
<!-- Yandex.Metrika counter --><script type="text/javascript">var yaParams = {/*Здесь параметры визита*/};</script><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter23652886 = new Ya.Metrika({id:23652886, webvisor:true, clickmap:true, trackLinks:true, accurateTrackBounce:true, trackHash:true,params:window.yaParams||{ }}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/23652886" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Anton Davydov</a>
            <small>Blog</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/11/01/write-simple-lisp-on-ruby-part-1/">
        Write simple scheme interpreter on ruby
      </a>
    </h1>

    <span class="post-date">01 Nov 2015</span>

    <p><strong>TL;DR:</strong> <a href="https://github.com/davydovanton/rlisp">github repo</a></p>

<p>Every developer has a moment in his life when he wants to write his own programming language.
So in this article I want to show you how to do this for a simple lisp compiler.</p>

<h2 id="why-scheme-and-lisp">Why scheme and lisp?</h2>
<p>Firstly, lisp is very simple for realization and for understanding.
Lisp (<em>LISt Processor</em>) is a family of languages which based on the idea of S-expressions.
S-Expression needed for data representation and may consist of atoms (numbers, symbols, boolean expressions) or an expression of the form <code>(x . y)</code> where <code>x</code> and <code>y</code> are s-expressions.
This expression may be formed as lists (<code>(1 . ( 2 . 3))</code> this equals <code>(1 2 3)</code>) and trees (<code>((1 . (2 . 3)) . (4 . 5))</code>).</p>

<p>Secondly, after creating interpreter you can better to understand language (author fully understood the environment idea).
Also you can understand main idea of compilers and interpreters.</p>

<p>So we begin our journey into the world of compilers and interpreters to write a simple scheme interpreter.</p>

<h2 id="main-idea">Main idea</h2>
<p>Our language will contain two parts: parser which translate string to AST and <code>eval</code> function.
This function will take the AST with envariement value and will returns result of the code.</p>

<p>Schematically, it looks like this:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">code(string) =&gt; parse function =&gt; AST =&gt; eval function =&gt; result</code></pre></div>

<h2 id="first-step-parser">First step. Parser.</h2>
<p>To begin, let’s define what we want to get.
For example, we have a string <code>'(+ 1 1 1)'</code>.
What our parser should return? What kind of data structure? I think, that array will be correctly.</p>

<p>Let write simple test code:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">program</span> <span class="o">=</span> <span class="s1">&#39;(+ 1 1 1)&#39;</span>
<span class="n">lisp</span> <span class="o">=</span> <span class="no">Lisp</span><span class="o">.</span><span class="n">new</span>
<span class="n">lisp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="o">==</span> <span class="o">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span></code></pre></div>

<p>As you can see, this is simple code therefore I just display <code>parse</code> method code:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Lisp</span>
  <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="n">tokenize</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
    <span class="n">chars</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\s\s+/</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39; ( &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39; ) &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">token</span><span class="o">|</span> <span class="n">atom</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">}</span>
      <span class="o">.</span><span class="n">compact</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">[</span><span class="sr">/\.\d+/</span><span class="o">]</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_f</span>
    <span class="k">elsif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span> <span class="o">||</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span>
      <span class="kp">nil</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="o">[</span><span class="sr">/\d+/</span><span class="o">]</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_i</span>
    <span class="k">else</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_sym</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>As you know, in lisp you can write your code with nested operators, for example - <code>(+ (* 2 2) (- 5 3))</code>.
And this code will return 6.</p>

<p>If we use our parser for this code, we get is not quite what we need, so let’s update our test code:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">program</span> <span class="o">=</span> <span class="s1">&#39;(+ (* (1 2) 3) 4)&#39;</span>
<span class="n">lisp</span> <span class="o">=</span> <span class="no">Lisp</span><span class="o">.</span><span class="n">new</span>
<span class="n">lisp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="o">==</span> <span class="o">[</span><span class="ss">:+</span><span class="p">,</span> <span class="o">[</span><span class="ss">:*</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">,</span> <span class="mi">4</span><span class="o">]</span></code></pre></div>

<p>As you might guess, the most obvious way to fix our code - call <code>parse</code> method in recursion and all array elements from <code>'('</code> to <code>')'</code> we move to nested array.
Code will be look loke this:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Lisp</span>
  <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="n">read_from_tokens</span><span class="p">(</span><span class="n">tokenize</span><span class="p">(</span><span class="n">program</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
    <span class="n">chars</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\s\s+/</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39; ( &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39; ) &#39;</span><span class="p">)</span>
      <span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read_from_tokens</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">if</span> <span class="n">tokens</span><span class="o">.</span><span class="n">empty?</span>

    <span class="n">token</span> <span class="o">=</span> <span class="n">tokens</span><span class="o">.</span><span class="n">shift</span>

    <span class="k">if</span> <span class="s1">&#39;(&#39;</span> <span class="o">==</span> <span class="n">token</span>
      <span class="n">list</span> <span class="o">=</span> <span class="o">[]</span>

      <span class="k">while</span> <span class="n">tokens</span><span class="o">.</span><span class="n">first</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span>
        <span class="n">list</span> <span class="o">&lt;&lt;</span> <span class="n">read_from_tokens</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">tokens</span><span class="o">.</span><span class="n">shift</span>

      <span class="n">list</span>
    <span class="k">elsif</span> <span class="s1">&#39;)&#39;</span> <span class="o">==</span> <span class="n">token</span>
      <span class="k">raise</span> <span class="s1">&#39;unexpected )&#39;</span>
    <span class="k">else</span>
      <span class="n">atom</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">token</span><span class="o">[</span><span class="sr">/\.\d+/</span><span class="o">]</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_f</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="o">[</span><span class="sr">/\d+/</span><span class="o">]</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_i</span>
    <span class="k">else</span>
      <span class="n">token</span><span class="o">.</span><span class="n">to_sym</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>We did it! Let’s start make <code>eval</code> method.</p>

<h2 id="eval-method">Eval method</h2>
<p>As I said earlier, our interpreter consist of two parts: parser and <code>eval</code> function.</p>

<p>The <code>eval</code> function will take two arguments: an expression, <code>exp</code>, that we want to evaluate, and an environment, <code>env</code>, in which to evaluate it. An environment is a mapping from variable names to their values.
By default, eval will use a instance value that includes the names for a bunch of standard things.</p>

<p>let’s implement <code>@env</code> variable with <code>car</code>, <code>cdr</code> and <code>cons</code> functions:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">:car</span>  <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">},</span>
  <span class="ss">:cdr</span>  <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">.</span><span class="n">drop</span> <span class="mi">1</span> <span class="p">},</span>
  <span class="ss">:cons</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">cell</span><span class="p">),</span> <span class="n">_</span><span class="o">|</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="o">+</span> <span class="n">cell</span> <span class="p">},</span>
<span class="p">}</span></code></pre></div>

<p>Next step - make <code>eval</code> function which will look for a match on the first element of the input array</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Lisp</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ext</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@env</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">:car</span>   <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">},</span>
      <span class="ss">:cdr</span>   <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">.</span><span class="n">drop</span> <span class="mi">1</span> <span class="p">},</span>
      <span class="ss">:cons</span>  <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">cell</span><span class="p">),</span> <span class="n">_</span><span class="o">|</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="o">+</span> <span class="n">cell</span> <span class="p">},</span>
    <span class="p">}</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span> <span class="o">=</span> <span class="vi">@env</span><span class="p">)</span>
    <span class="n">env</span><span class="o">[</span><span class="n">exp</span><span class="o">.</span><span class="n">first</span><span class="o">].</span><span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></div>

<p>Now we have a problem: what will be happen when the first element of array will be not symbol (integer for example) and what will be happen when we have nested functiions?
I think we can add check to element type like this:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Lisp</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ext</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@env</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">:car</span>   <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">},</span>
      <span class="ss">:cdr</span>   <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">list</span><span class="o">|</span> <span class="n">list</span><span class="o">.</span><span class="n">drop</span> <span class="mi">1</span> <span class="p">},</span>
      <span class="ss">:cons</span>  <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">cell</span><span class="p">),</span> <span class="n">_</span><span class="o">|</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span> <span class="o">+</span> <span class="n">cell</span> <span class="p">},</span>
    <span class="p">}</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span> <span class="o">=</span> <span class="vi">@env</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Numeric</span>
      <span class="n">exp</span>
    <span class="k">elsif</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Symbol</span>
      <span class="n">env</span><span class="o">[</span><span class="n">exp</span><span class="o">]</span>
    <span class="k">else</span>
      <span class="n">code</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
      <span class="n">args</span> <span class="o">=</span> <span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span> <span class="nb">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">code</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></div>

<p>Some (eg arithmetic), we can easily add to <code>env</code> variable, and some do not.
Therefore we need to extend checking in <code>eval</code> function. We will add check on function name.
For example, code bellow demonstrate <code>quote</code> and <code>if</code> functions:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:quote</span>
    <span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
  <span class="k">elsif</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:if</span>
    <span class="n">_</span><span class="p">,</span> <span class="nb">test</span><span class="p">,</span> <span class="n">conseq</span><span class="p">,</span> <span class="n">alt</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="p">?</span> <span class="n">conseq</span> <span class="p">:</span> <span class="n">alt</span>
    <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></div>

<p>Next step - initialize <code>define</code> and <code>lambda</code> functions.
In scheme <code>define</code> function syntax is as follows:</p>

<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">name</span>
  <span class="p">(</span><span class="nf">expression</span><span class="p">))</span></code></pre></div>

<p>And our code must create a new key-value pair in the <code>env</code> hash:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:define</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="n">env</span><span class="o">[</span><span class="n">var</span><span class="o">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></div>

<p>Last function, ‘lambda’ in scheme have this syntax:</p>

<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">arg1,</span> <span class="nv">arg2,</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">block</span> <span class="nv">of</span> <span class="nv">code</span><span class="p">))</span></code></pre></div>

<p>The first thing that comes to mind - to return a new <code>lambda</code> object with a new value inside <code>env</code> that will serve our code:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:lambda</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="no">Hash</span><span class="o">[</span><span class="n">params</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">]</span><span class="p">))</span> <span class="p">}</span>
  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></div>

<p>As you can see we did basic functionality of the our interpreter.
Implementating of arithmetic methods, and implementing methods such as <code>true</code>,<code> false</code>, <code>list</code>, etc I leave on the conscience of the reader.</p>

<h2 id="repl">REPL</h2>
<p>In main REPL have realy simple idea: repl takes single user inputs, evaluates them, and returns the result to the user.
And all this is happening in an infinite loop:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">prompt</span> <span class="o">=</span> <span class="s1">&#39;lisp &gt;&gt; &#39;</span><span class="p">)</span>
  <span class="k">while</span> <span class="kp">true</span>
    <span class="nb">print</span> <span class="n">prompt</span>
    <span class="n">program</span> <span class="o">=</span> <span class="nb">gets</span>

    <span class="nb">p</span> <span class="nb">eval</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>As a result, you should get something like this:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">lisp &gt;&gt; (define pi 3.14)
3.14
lisp &gt;&gt; (define circle-area (lambda (r) (* pi (* r r))))
#&lt;Proc:0x007fa6140c6cc0@lib/rlisp.rb:86 (lambda)&gt;
lisp &gt;&gt; (circle-area 11)
379.94</code></pre></div>

<h2 id="conclusions">Conclusions</h2>
<p>At this moment we have a simple scheme interpreter.
It is easy to expand, we wrote a simple repl, and considered the basic idea of the interpreter.
In this article we does not consider such important aspects as macros, multithreading, code optimization, work with the system, and much more.
This will be discussed in future articles.</p>

<h2 id="further-reading">Further reading</h2>
<p>http://norvig.com/lispy.html
http://www.wikiwand.com/en/S-expression</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/10/26/get-requiest-with-custom-locale-in-your-tests/">
        Get request with custom locale in your tests
      </a>
    </h1>

    <span class="post-date">26 Oct 2015</span>

    <p>Sometimes in tests you have to set special locale for <code>get</code> request.
For example you want to <a href="https://github.com/mperham/sidekiq/blob/master/test/test_web.rb#L33-L50">test selecting locale language</a>.
For this you have to set locale in <code>'HTTP_ACCEPT_LANGUAGE'</code> variable in params hash.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;your test description&#39;</span> <span class="k">do</span>
  <span class="n">rackenv</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;HTTP_ACCEPT_LANGUAGE&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;ru,en&#39;</span><span class="p">}</span>
  <span class="n">get</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">rackenv</span>

  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span></code></pre></div>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/04/05/ruby-memory-profiller-tools/">
        Memory profiler tools for ruby
      </a>
    </h1>

    <span class="post-date">05 Apr 2015</span>

    <p>Memory profiler tools for ruby It so happened that I was need know how much ruby objects created
for each call sidekiq <code>perform_async</code> method
(<a href="https://github.com/mperham/sidekiq/pull/2288">mperham/sidekiq#2288</a>).
That’s why I decided to create list with tools which helps you to know all required information.</p>

<h2 id="ruby-gc">1. Ruby GC</h2>
<p>Sam Saffron has written great post, in which he talk about ruby garbage collector and wonderful
<code>GC.start</code> method which returns data hash:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="no">GC</span><span class="o">.</span><span class="n">stat</span>
<span class="c1"># =&gt; {:count=&gt;21, :heap_allocated_pages=&gt;236, :heap_sorted_length=&gt;237, :heap_allocatable_pages=&gt;0, :heap_available_slots=&gt;96193, :heap_live_slots=&gt;95354, … }</span></code></pre></div>

<p>Also author mentions a <code>ObjectSpace</code> module that lets you know information about object/memory management.
For example you can easily know general number of created objects. For this you need write this code:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="no">ObjectSpace</span><span class="o">.</span><span class="n">count_objects</span><span class="o">[</span><span class="ss">:TOTAL</span><span class="o">]</span>
<span class="c1"># =&gt; 96193</span></code></pre></div>

<h2 id="ruby-memory-profiler">2. Ruby Memory Profiler</h2>
<p>Also Sam wrote great tool (<a href="https://github.com/SamSaffron/memory_profiler">ruby-memory-profiler</a>) which provide
easily display all required information for any code in block. For this you will need call something like
this (I called this code in my sidekiq reduce allocation PR):</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">MemoryProfiler</span><span class="o">.</span><span class="n">report</span><span class="p">{</span> <span class="mi">100</span><span class="o">.</span><span class="n">times</span><span class="p">{</span> <span class="no">HardWorker</span><span class="o">.</span><span class="n">perform_async</span> <span class="p">}</span> <span class="p">}</span><span class="o">.</span><span class="n">pretty_print</span></code></pre></div>

<h2 id="ruby-prof">3. ruby-prof</h2>
<p>General features:</p>

<ul>
  <li>display <a href="https://github.com/ruby-prof/ruby-prof#reports">different</a> reports;</li>
  <li>fast;</li>
  <li>easily profiles rails apps;</li>
</ul>

<p>How to use:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">&#39;ruby-prof&#39;</span>

<span class="c1"># Profile the code</span>
<span class="no">RubyProf</span><span class="o">.</span><span class="n">start</span>
<span class="c1"># [code to profile]</span>
<span class="no">RubyProf</span><span class="o">.</span><span class="n">pause</span>
<span class="c1"># [other code]</span>
<span class="no">RubyProf</span><span class="o">.</span><span class="n">resume</span>
<span class="c1"># [code to profile]</span>
<span class="n">result</span> <span class="o">=</span> <span class="no">RubyProf</span><span class="o">.</span><span class="n">stop</span></code></pre></div>

<h2 id="conclusions">Conclusions</h2>
<p>Profiling Ruby isn’t as difficult as it seems at first glance. There are a lot of great
libraries. The only thing I was missing — profiling the code from a file, but I’m sure it will soon add
(maybe it will add myself ☺ ).</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/03/29/specific-color-hash/">
        Convert string to color hash
      </a>
    </h1>

    <span class="post-date">29 Mar 2015</span>

    <p>So it happens that sometimes you need to convert string to color hash. I think that
<code>Digest::MD5</code> class is easiest way for this. For this you need call hexdigest method
with necessary string.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s1">&#39;My string&#39;</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="o">]</span> <span class="c1"># =&gt; &#39;a537d0&#39;</span></code></pre></div>

<p>And if you will create rgb color you need convert hex to decimal with <code>to_i(16)</code> method.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="o">]</span>
  <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
  <span class="o">.</span><span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">color</span><span class="o">|</span> <span class="n">color</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">}</span></code></pre></div>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/16/vim-history/">
        История vim
      </a>
    </h1>

    <span class="post-date">16 Mar 2014</span>

    <p>Я свято верю, что перед тем, как изучать новую технологию, необходимо узнать, зачем и в каких условиях она была создана. Думаю, данные знания позволяют в будущем не только не забивать гвозди микроскопом, но и не спрашивать, почему они так плохо забиваются. Поэтому первую запись из цикла статей, связанных с vim-ом, я бы хотел начать с истории его становления и небольшого описания его функционала.</p>

<p>Представьте себе: 70тые годы, расцвет unix машин, на данный момент существует только текстовый редактор <a href="http://en.wikipedia.org/wiki/Ed_(text_editor)">ed</a>, который является командно-ориентированным, а за ним появляется редактор <a href="http://en.wikipedia.org/wiki/Ex_(text_editor)">ex</a>. Во времена первого никто не слышал о мониторах, поэтому использовали для ввода телетайпы, из-за чего ed имеет командно-ориентированный интерфейс. А ex, в свою очередь, являлся улучшеным ed. Поэтому в нем появились такие штуки как экранное редактирование и работа с несколькими файлами, что для тех времен является прорывом. В это время многие программисты начинают писать свои редакторы, и один из них, <a href="http://en.wikipedia.org/wiki/Bill_Joy">Билл Джой</a>, придумывает логичную и простую концепцию поверх редактора ex. Во первых, было бы логично воспринимать текст как объект, к которому применяются команды редактирования. Во вторых, использование unix идеологии о простоте и взаимности комманд. Так, в 1976 году, появляется первая версия текстового редактора vi, сокращено от (visual). Давайте рассмотрим каждую из концепций отдельно.</p>

<p>Во первых, человек часто мыслит абстрактно, поэтому мы никогда не воспринимает набор последовательных символов как непосредственно набор последовательных символов. Наш разум создает абстракции, такие как слова, предложения, параграфы или абзацы и тому подобные. Так почему бы нам не реализовать эту же идею в текстовом редакторе? Думаю, этим же вопросом задался Билл Джой, и поэтому vi оперирует не просто с набором символов, как многие другие текстовые редакторы, а оперирует непосредственно объектами-абстракциями: словами, строками, параграфами.</p>

<p>Допустим, мы смогли реализовать такую идею внутри редактора, но теперь встает вопрос, что делать с этими объектами? Да собственно то же самое, что мы, доблестные воины клавиатуры и текста, делаем с ними каждый день - изменять их посредством передачи в функций. Кстати, часть функций можно позаимствовать из unix-а, например, sort и ему подобные. Поэтому на данный момент наше взаимодействие с редактором можно описать простым набором функций вида: [комманда] [объект].</p>

<p>А теперь самое интересное, как мы реализуем такое количество комманд и способов выбора объектов, и при этом нам надо как то печатать обычный текст. Думаю, многие понимают, что использовать все клавиши для комманд и для набора текста - не реально вообще никак. А тем более на такой клавиатуре, которую использовали в терминалах того времени.</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/KB_Terminal_ADM3A.svg/1000px-KB_Terminal_ADM3A.svg.png" alt="old unix keybord" /></p>

<p>Кстати, небольшой оффтоп, вы никогда не задумывались, откуда пошло, что символ ‘~’ в nix like системах обозначает home дирикторию? Посмотрите внимательно на клавиатуру выше, а именно на клавишу home ;)</p>

<p>Так вот, тут-то мы и приходим к модальному интерфейсу. Что же это значит? Это значит, что существует несколько режимов, в которых различные клавиши выполняют различные комманды. В vi было целых 2 режима: режим вставки, в котором пользователь мог набирать текст, и коммандный режим, в котором пользователь, посредством нажатия комбинаций клавиш, работает с текстом.</p>

<p>Вся прелесть данного текстового редактора была не только в его инновациях, но и в его открытости, что позволило в 1991 году <a href="http://en.wikipedia.org/wiki/Bram_Moolenaar">Браму Мооленару</a> создать первую версию vim, которая расшифровывается как <strong>V</strong>i <strong>im</strong>proved. В нем было очень много нового, например, визуальный режим, макросы, работа с кучей файлов одновременно, итеграция с ОС и так далее.</p>

<p>Так что же это все дает нам, обычным программистам? Во первых, мы можем приобщиться к истории, а если серьезно - ввиду того, что раньше не было мыши, то все комманды печатались на клавиатуре, и никакие Васи не тыкали мышкой в кнопочки на экране. Ну а так как тыкаться мышкой в интерфейсе дольше, чем использовать хоткеи, то мы получаем довольно сильный профит в скорости. Во вторых, интерфейс не перегружен излишней функциональностью, как во многих IDE или текстовых редакторах. Предлагаю вам сравнить скриншоты vim-а и какого-нибудь eclipse.</p>

<p><a class="lightbox" href="http://2.bp.blogspot.com/_ZzOZmj1dP0c/TNcTx8DygaI/AAAAAAAAA0Q/Ar2BsQs11VI/s1600/gvim.png">
<img src="http://2.bp.blogspot.com/_ZzOZmj1dP0c/TNcTx8DygaI/AAAAAAAAA0Q/Ar2BsQs11VI/s1600/gvim.png" alt="Vim" />
</a>
<a class="lightbox" href="http://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Eclipse_4.3.Kepler_screenshot.png/800px-Eclipse_4.3.Kepler_screenshot.png">
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Eclipse_4.3.Kepler_screenshot.png/800px-Eclipse_4.3.Kepler_screenshot.png" alt="Eclipse" />
</a></p>

<p>Сказать по правде, я давно хотел спросить, вы часто тыкаете во все эти кнопки в cтроке наверху?</p>

<p>В третьих, вы получаете необычный, и оттого интересный, удобный, после привыкания, способ взаимодействия с текстом. Подумайте сами, вы взаимодействуете с текстом как с объектом, а не как с набором символов, что позволяет вам выбирать не просто последовательность символов, а целые слова, параграфы, линии, блоки текста и оперировать с ними как захотите.</p>

<p>Но для начала стоит вернуться к режимам. В vim-е их 4: нормальный, в котором вы посредством хоткеев выполняете операции над текстом; коммандный, в котором вы можете вводить комманды как в консоли(и, кстати, выполнять консольные комманды тоже); режим вставки, в котором вы можете набирать текст и оперировать им, как в обычном текстовом редакторе, а-ля sublime; ну и последний, визуальный, в котором вы можете выбирать текст для дальнейшего взаимодействия с ним. Стоит отметить, что визуальных режимов 3 - обычный, в котором вы выбираете текст посимвольно, строчный, в котором вы вы выбираете текст построчно, и блочный, в этом режиме вы задаете 2 точки прямоугольника, весь текст в котором выделяется и пригоден для взаимодействия. ( Сказать по правде, есть еще один режим, режим эмуляции ex редактора. Вызывается он с помощью <code>Q</code>, обязательно с шифтом, после чего вы попадаете в отдельное окно, в котором вы можете вводить комманды без префикса <code>:</code>. Чтобы выйти из этого режима достаточно набрать <code>visual</code> или <code>vi</code>. Для справки советую набрать <code>:h Ex-mode</code> в vim. )</p>

<p>Исходя из всего, что я написал выше - вам придется полностью изменить свое отношение к взаимодействию с текстом, что, в свою очередь, позволит вам увеличить вашу скорость редактирования/поиска текста. Скажу сразу, это непривычно, но с другой стороны, это как изучение нового языка программирования. Вы можете оставаться в собственной зоне комфорта, а можете сломать свой мозг, изучив какой-нибудь lisp или haskell. Тут то же самое, вы можете всю жизнь использовать привычный sublime, а можете попробовать что-то новое. Ну а в следующей записи мы более детально обсудим редактор и рассмотрим, как же он может облегчить нам жизнь.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/10/seed-and-you/">
        Seed файл и вы
      </a>
    </h1>

    <span class="post-date">10 Mar 2014</span>

    <p>Совсем недавно, на работе, потребовалось мне заполнить новый проект данными для дальнейшего тестирования и разработки. Конечно же, данные должны быть в любом виде, и первое, о чем я подумал, был seed файл, поэтому сегодня мы поговорим именно о нем. Как всем известно, данный файл служит для генерации данных в рельсовых приложениях. Вы пишите скрипт, выполняете <code>rake db:seed</code> и радуетесь жизни. В моем случае данные были типовыми, а именно, нужно было сгенерировать пользователей, посты и комментарии к этим постам. Я думаю все прекрасно понимают, как все взаимосвязанно, поэтому на этом останавливаться не вижу особого смысла.</p>

<p>Обычная практика многих людей - задать одинаковые данные для всех типов данных и наплодить их с десяток. Смотрится это обычно как-то так:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nb">name</span><span class="p">:</span>  <span class="s1">&#39;Jon&#39;</span>
  <span class="ss">email</span><span class="p">:</span> <span class="s1">&#39;my@email.org&#39;</span>
  <span class="ss">password</span><span class="p">:</span> <span class="s1">&#39;12345678&#39;</span><span class="p">,</span>
  <span class="ss">password_confirmation</span><span class="p">:</span> <span class="s1">&#39;12345678&#39;</span>  
  <span class="p">}</span>

<span class="n">post</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">title</span><span class="p">:</span>  <span class="s1">&#39;My Post&#39;</span>
  <span class="ss">body</span><span class="p">:</span>   <span class="s1">&#39;My body&#39;</span>
  <span class="p">}</span>

<span class="n">comment</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">body</span><span class="p">:</span> <span class="s1">&#39;comment&#39;</span> <span class="p">}</span>

<span class="mi">10</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
  <span class="n">my_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
  <span class="n">my_post</span> <span class="o">=</span> <span class="n">my_user</span><span class="o">.</span><span class="n">create_post</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
  <span class="n">my_post</span><span class="o">.</span><span class="n">create_comment</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
<span class="k">end</span></code></pre></div>

<p>Но согласитесь, это скучно, банально и задевает чувство прекрасного. Поэтому давайте плюнем на все и развлечемся, создав свой собственный, изменяющийся из раза в раз мир :)</p>

<p><em><strong>ATTENTION</strong>: далее будет много рандома, благодаря которому поддерживать все это или искать ошибки становится все сложнее и сложнее. Поэтому, использование генераторов, основанных на рандоме не рекомендуется для продакшена. В крайнем, случае использовать аккуратно и с умом.</em></p>

<p>Для того, чтобы наш воображаемый мир существовал, нам, естественно, нужны пользователи. И наша цель - создать абсолютно разных пользователей, не похожих друг на друга. Конечно же, первое, что всплывает в голову - замечательный гем <a href="https://github.com/stympy/faker">faker</a>, который поможет нам генерировать произвольные имена и почтовые адресса для наших пользователей. Но при всем при этом, не будем забывать про нашего админа. Так же, давайте зададим рандомное количество записей в интервале от 18 до 25 штук (числа, как вы догадались, могут быть абсолютно любые):</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nb">name</span><span class="p">:</span>  <span class="n">admin</span>
  <span class="ss">email</span><span class="p">:</span> <span class="n">admin</span><span class="vi">@my_app</span><span class="o">.</span><span class="n">com</span>
  <span class="ss">password</span><span class="p">:</span> <span class="s1">&#39;12345678&#39;</span><span class="p">,</span>
  <span class="ss">password_confirmation</span><span class="p">:</span> <span class="s1">&#39;12345678&#39;</span>  
  <span class="p">}</span>

<span class="n">rnd</span> <span class="o">=</span> <span class="no">Random</span><span class="o">.</span><span class="n">new</span>
<span class="n">user_count</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">18</span><span class="o">.</span><span class="n">.</span><span class="mi">23</span><span class="p">)</span>
<span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

<span class="n">user_count</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
  <span class="n">user</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>  <span class="o">=</span> <span class="no">Faker</span><span class="o">::</span><span class="no">Name</span><span class="o">.</span><span class="n">name</span>
  <span class="n">user</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span> <span class="o">=</span> <span class="no">Faker</span><span class="o">::</span><span class="no">Internet</span><span class="o">.</span><span class="n">email</span>  
  <span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="k">end</span></code></pre></div>

<p>Cобственно я уверен, faker поможет вам сгенерировать почти любую информацию, стоит только открыть доки. Ну а если вам не угодил этот гем, то существует достаточно <a href="https://www.ruby-toolbox.com/categories/random_data_generation">много</a> других data генераторов.</p>

<p>Не думаю, что тут что-то было сложно, поэтому пререйдем к постам. Сказать по правде, в нашем проекте посты состояли из строго заданных кусков html-a, поэтому тут ничего не оставалось, кроме как делать в лоб. Единственный момент, мы будем выбирать произвольно пользователя, чтобы от его имени создавать наш пост:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">posts</span> <span class="o">=</span> <span class="o">[</span>
  <span class="p">{</span>
    <span class="ss">title</span><span class="p">:</span>  <span class="s1">&#39;My first Post&#39;</span>
    <span class="ss">body</span><span class="p">:</span>   <span class="s1">&#39;My body&#39;</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="ss">title</span><span class="p">:</span>  <span class="s1">&#39;My second Post&#39;</span>
    <span class="ss">body</span><span class="p">:</span>   <span class="s1">&#39;My body&#39;</span>    
  <span class="p">},</span>
  <span class="c1"># Еще какое-то количество данных для постов ...</span>
<span class="o">]</span>

<span class="k">def</span> <span class="nf">rnd_user</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
  <span class="n">random_user_id</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
  <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">random_user_id</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
  <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>

  <span class="n">post</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">id</span>
  <span class="n">created_post</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">create_post</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
<span class="k">end</span></code></pre></div>

<p>Настало время самого интересного и забавного, комментарии. В данном проекте мы использовали гем <a href="https://github.com/elight/acts_as_commentable_with_threading">acts_as_commentable_with_threading</a>. Он содержит 2ух уровневую структуру комментариев, поэтому работы нам немного прибавилось. Чтобы создать комментарий, нам необходимы 3 значения: пост, где будет этот комментарий, пользователь, оставивший комментарий, и непосредственно сам текст комментария. Смотрится все это примерно так:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span></code></pre></div>

<p>Ну а для “подкомментария” нам так же необходимо знать родительский комментарий, от которого ветка и пойдет, т.е. создание подобного комментария будет выглядеть примерно так:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">child_comment</span> <span class="o">=</span> <span class="n">post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
<span class="n">child_comment</span><span class="o">.</span><span class="n">move_to_child_of</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span></code></pre></div>

<p>А теперь давайте создадим от 10 до 21 главных комментариев и до 9ти дочерних для каждого главного, при этом каждый комментарий будет оставлять рандомный пользователь:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
  <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>

  <span class="n">post</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">id</span>
  <span class="n">created_post</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">create_post</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>

  <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">.</span><span class="n">.</span><span class="mi">21</span><span class="p">)</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
    <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">created_post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">rand_user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;Comment body&#39;</span><span class="p">)</span>
    <span class="n">comment</span><span class="o">.</span><span class="n">save!</span>

    <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
      <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>
      <span class="n">child_comment</span> <span class="o">=</span> <span class="n">created_post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">rand_user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;Comment body&#39;</span><span class="p">)</span>
      <span class="n">child_comment</span><span class="o">.</span><span class="n">save!</span>
      <span class="n">child_comment</span><span class="o">.</span><span class="n">move_to_child_of</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Хм, рандомное количество комментариев мы сделали, пользователей тоже разных назначили, но вот незадача, у нас body каждого комментария одно и тоже, а именно <code>'Comment body'</code>.Что же делать и как нам быть? Раз уж мы договорились создать подобие “живого” приложения, то и комментарии у нас должны быть разные и тоже живые. Первое, что приходит в голову, - опять использовать массив данных, но я слишков ленив (да и не путь самурая это), чтобы все это набирать, пусть даже копипастить и тем более придумывать. Второе, что приходит на ум, генерировать рандомную строчку текста. Да, идея не плохая, как минимум, нам придется писать меньше кода, и он по-любому будет всегда разный. Но есть одно но: мы пытаемся достигнуть абсолютной правдоподобности, а строки вида <code>'skjafnskdjn ksajdnf'</code> нам точно не подойдут как комментарии. Поэтому нам на помощь приходит отличное решение - гем <a href="https://github.com/postmodern/raingrams">raingrams</a>.</p>

<p>Что же такого может этот гем, спросите Вы? На самом деле, ничего особенного, Вы просто скармливаете ему текст, а он, в свою очередь, разбивает его на куски и рандомно выдает обратно. В чем плюсы? Да, они не отличаются от банальной генерации строки, единственное и очевидное отличие - генерируемый текст будет логичен в пределах строки.</p>

<p>В документации достаточно подробно описано, как гем ставится и настраивается, но я бы хотел уделить внимание 2ум подводным камням, с которыми мы столкнулись:</p>

<ul>
  <li>
    <p>Во первых, гем не поддерживает русский язык. Скажем так, он его не видит. Поэтому, если для Вас важен русский язык, используйте наш <a href="https://github.com/dointeractive/raingrams">форк</a>, в котором исправлен этот косяк.</p>
  </li>
  <li>
    <p>Ну а второй момент, в старых версиях существовал метод <code>train_with_url</code>, в который передавалась ссылка, а он уже все парсил и выдавал конечный результат. К сожалению, в свежих версиях этот метод был убран, причем убран очень хитро. Если быть точным, то автор просто вырезал часть этого метода, а вторую забыл(а может, решил стебануться над простыми парнями как мы, этого я, к сожалению, не знаю :) ).</p>
  </li>
</ul>

<p>А теперь, используя полученные знания, перепишем наш метод. В качестве текста для raingrams мы будем использовать комментарии из пикабу, которые предварительно распарсим:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">model</span> <span class="o">=</span> <span class="no">QuadgramModel</span><span class="o">.</span><span class="n">build</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="o">|</span>
  <span class="n">doc</span> <span class="o">=</span> <span class="no">Nokogiri</span><span class="o">::</span><span class="no">HTML</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;http://pikabu.ru/story/v_den_programmista_pro_logiku_pikabu_685289&#39;</span><span class="p">))</span>
  <span class="n">doc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;div.comment_desc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">div</span><span class="o">|</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train_with_text</span><span class="p">(</span><span class="n">div</span><span class="o">.</span><span class="n">inner_text</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">refresh</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ....</span>

<span class="n">posts</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
  <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>

  <span class="n">post</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">id</span>
  <span class="n">created_post</span> <span class="o">=</span> <span class="n">rand_user</span><span class="o">.</span><span class="n">create_post</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>

  <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">.</span><span class="n">.</span><span class="mi">21</span><span class="p">)</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
    <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">created_post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">rand_user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">random_sentence</span><span class="p">)</span>
    <span class="n">comment</span><span class="o">.</span><span class="n">save!</span>

    <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
      <span class="n">rand_user</span> <span class="o">=</span> <span class="n">rnd_user</span> <span class="n">user_count</span><span class="p">,</span> <span class="n">rnd</span>
      <span class="n">child_comment</span> <span class="o">=</span> <span class="n">created_post</span><span class="o">.</span><span class="n">build_comment</span><span class="p">(</span><span class="n">rand_user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">random_sentence</span><span class="p">)</span>
      <span class="n">child_comment</span><span class="o">.</span><span class="n">save!</span>
      <span class="n">child_comment</span><span class="o">.</span><span class="n">move_to_child_of</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Кстати, я уверен, что немного изменив наш скрипт, можно будет создать подобную генератию текстов непосредственно для постов.</p>

<p>Выглядит здорово. Да, может, код не самый чистый, и в целом скрипт слишком часто обращается к базе, но согласитесь, наше творение имитирует реальную активность пользователей. Не идеально, конечно, но все же. Думаю, на этом можно было бы закончить рассказ, но остался последний момент, который хотелось бы осветить и исправить в нашем скрипте.</p>

<p>Как думаете, где еще нам придется создавать пользователей (и не только их), которых мы создали в самом начале? Правильно, в тестах, надо же на чем-то тестировать приложение. Так почему бы нам не убить 2ух зайцев и не заменить ручную генерацию, как это было в начале статьи, на старую добрую фабричную? Так как в нашем проекте мы используем гем  <a href="http://www.fabricationgem.org/">fabrication</a>, то и пример будет с ним. Вы также можете использовать любую другуюю фабрику, которая вам по вкусу.</p>

<p>Для начала определим нашего пользователя и администратора:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Fabricator</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">email</span> <span class="no">Faker</span><span class="o">::</span><span class="no">Internet</span><span class="o">.</span><span class="n">email</span>
  <span class="nb">name</span> <span class="no">Faker</span><span class="o">::</span><span class="no">Name</span><span class="o">.</span><span class="n">name</span>
  <span class="n">password</span> <span class="s1">&#39;12345678&#39;</span>
  <span class="n">password_confirmation</span> <span class="s1">&#39;12345678&#39;</span>
<span class="k">end</span>

<span class="no">Fabricator</span><span class="p">(</span><span class="ss">:admin</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">email</span> <span class="s1">&#39;admin@my_app.org&#39;</span>
  <span class="nb">name</span> <span class="s1">&#39;admin&#39;</span>
  <span class="n">password</span> <span class="s1">&#39;12345678&#39;</span>
  <span class="n">password_confirmation</span> <span class="s1">&#39;12345678&#39;</span>
<span class="k">end</span></code></pre></div>

<p>Ну а теперь, воспользуемся нашей новосозданной фабрикой для избавления от лишнего кода в seed файле:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">user_count</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">18</span><span class="o">.</span><span class="n">.</span><span class="mi">23</span><span class="p">)</span>
<span class="no">Fabricate</span><span class="p">(</span><span class="ss">:admin</span><span class="p">)</span>

<span class="n">user_count</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="no">Fabricate</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span></code></pre></div>

<p>В итоге, мы смогли убрать достаточно приличный кусок cкрипта, избавшись от явного повтора кода.</p>

<p>На этом, пожалуй, я закончу наши эксперименты. Как видите, простора для фантазии осталось еще много и также осталось много идей для рефакторинга. В любом случае, данный пример явно показывает, что к любой, сколь скучной она не была бы, задаче всегда можно применить творческий подход и неплохо развлечься :)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/02/09/irb-and-all-all-all/">
        IRB и все все все
      </a>
    </h1>

    <span class="post-date">09 Feb 2014</span>

    <p>Думаю, каждый, кто так или иначе связан с Ruby и тем более с Rails, хоть раз в жизни использовал irb. Возможности интерактивного ruby шела безграничны, поэтому сегодня я бы хотел поговорить об улучшении или кастомизации, если вам так угодно, вашего irb.</p>

<p>Но для начала давайте посмотрим документацию, а именно откроем модуль <a href="http://www.ruby-doc.org/stdlib-2.0/libdoc/irb/rdoc/IRB.html">IRB</a> в стандартной библиотеке ruby.
“Что интересного тут есть?”, спросите вы? Думаю стоит начать с самого начала, с запуска. Если вы просто наберете в консоли <code>irb</code>, то запустите шел с вашей текущей версией руби. Но  если у вас RVM(хотя, сказать по правде я не уверен, что это работает только с RVM), то вы можете выбрать среду для запуска из всех тех, что у вас установлены. Например вот так, я, при активном MRI 2.0, могу запустить у себя jruby:</p>

<p><a class="lightbox" href="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/jruby-irb.png">
<img src="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/jruby-irb.png" alt="jruby in irb" />
</a></p>

<p>Дальше, думаю, следует обсудить ключи. Их много, они разные. В документации они все <a href="http://www.ruby-doc.org/stdlib-2.0/libdoc/irb/rdoc/IRB.html#module-IRB-label-Command+line+options">есть</a>. Самые интересные, на мой взляд, - <code>-d</code> включающий дебаг мод(аналогично <code>ruby -d</code>) и ключ <code>-I path</code>, загружающий указанную директорию.</p>

<p>Ну а теперь самое интересное: поговорим о конфигурации вашего irb. Для этого необходимо создать <code>*rc</code> аналогичный <code>.bashrc</code> или <code>.vimrc</code>. Существует несколько разновидностей именования этого файла, например: <code>.irbrc</code>, <code>irb.rc</code>, <code>_irbrc</code> или же <code>$irbrc</code>.</p>

<p>Думаю, для начала, следует указать конфигурационные значения, например, увеличить количество сохраняемых команд и записывать их в отдельный файл:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">IRB</span><span class="o">.</span><span class="n">conf</span><span class="o">[</span><span class="ss">:SAVE_HISTORY</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="no">IRB</span><span class="o">.</span><span class="n">conf</span><span class="o">[</span><span class="ss">:HISTORY_FILE</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;HOME&#39;</span><span class="o">]</span><span class="si">}</span><span class="s2">/.irb_history&quot;</span></code></pre></div>

<p>Так же можно указать кучу других настроек, но я бы не стал писать эту статью, если бы хотел рассказать только это. Все веселье начинается тогда, когда приходит понимание того, что данный файл является обычным <code>*.rb</code> файлом, который загружается при старте вашего irb.</p>

<p>Думаю, все догадались, что дальше будет? :)</p>

<p>Предлагаю написать, ради развлечения, метод, который возвращал бы все локальные методы объекта. Выглядеть он будет примерно так:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># .irbrc</span>
<span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">local_methods</span>
    <span class="p">(</span><span class="nb">methods</span> <span class="o">-</span> <span class="no">Object</span><span class="o">.</span><span class="n">instance_methods</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Как он будет работать, спросите вы? Да все просто, берете объект и вызываете на нем данный метод:</p>

<p><a class="lightbox" href="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/irb_local_methods.png">
<img src="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/irb_local_methods.png" alt="Using local_mathods method in irb" />
</a></p>

<p>Думаю, вы заметили цвета, которых не хватает в дефолтном irb?</p>

<p>Да, все верно, так же можно подключать гемы, и да, есть гемы, которые добавляют ярких цветов в ваш irb, например, <a href="https://github.com/blackwinter/wirble">wirble</a>. Достаточно написать такой код:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">&#39;rubygems&#39;</span>
<span class="nb">require</span> <span class="s1">&#39;wirble&#39;</span>

<span class="no">Wirble</span><span class="o">.</span><span class="n">init</span>
<span class="no">Wirble</span><span class="o">.</span><span class="n">colorize</span></code></pre></div>

<p>И ваш интерактивный шел заиграет новыми красками :)</p>

<p>А если вам нравится <a href="http://pryrepl.org/">pry</a>, то вам никто не запрещает его добавить, в последующем вызывая его, просто набрав <code>pry</code> во время irb сессии:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1">#.irbrc</span>
<span class="nb">require</span> <span class="s1">&#39;pry&#39;</span>

<span class="c1"># irb</span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">015</span> <span class="o">&gt;</span> <span class="n">pry</span>
<span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span></code></pre></div>

<p>Ну а выглядеть это будет как-то так:
<a class="lightbox" href="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/pry.gif">
<img src="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/pry.gif" alt="Using pry in irb" />
</a></p>

<p>Но самое полезное, что можно сделать, это забыть построчный ввод кода. “Как?”, спросите вы? Начну издалека: мне очень нравится vim :) Поэтому, смотря vimcasts-ы, я узнал то, что перевернуло мой мир, а именно: любой текстовый редактор можно <a href="http://vimcasts.org/episodes/running-vim-within-irb/">вызывать</a> прямо из irb.</p>

<p>Делается это очень просто: нужно добавить гем <code>interactive_editor</code>. Данный гем позволяет вызывать любой текстовый редактор из вашего irb, например, набрав <code>vim</code> - откроется vim, где вы сможете набрать любой код, который выполнится после сохранения файла и закрытия редактора.</p>

<p><a class="lightbox" href="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/vim-in-irb.gif">
<img src="http://davydovanton.github.io/images/2014/02/irb-and-all-all-all/vim-in-irb.gif" alt="Using vim in irb" />
</a></p>

<p>Собственно то же самое будет работать с sublime, textmate, emacs и <a href="https://github.com/jberkel/interactive_editor/blob/master/lib/interactive_editor.rb#L92">дургими</a> текстовыми редакторами.</p>

<p>Ну и на последок стоит рассказать про сессии в irb. Если вы используете vim или когда то использовали его, то вам знакомо такое понятие как буфер, которое чем-то похоже на сессии в irb. Ну а если нет, то краткая справка: сессия - некий сеанс интерактивного шела. Для того, что бы посмотреть список всех сессий в irb, достаточно набрать <code>jobs</code>:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">012</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: running)</span></code></pre></div>

<p>Ну а если вам надо создать новую сессию, то просто наберите <code>irb</code>:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">013</span> <span class="o">&gt;</span> <span class="n">irb</span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: stop)</span>
<span class="c1">#1-&gt;irb#1 on main (#&lt;Thread:0x007fcb819b7bf8&gt;: running)</span></code></pre></div>

<p>Как видите, irb создал новую сессию и переключился в нее. Но что делать, когда вы хотите удалить или изменить сессию? Для этого есть методы <code>kill &lt;number_session&gt;</code> и <code>fg &lt;number_session&gt;</code> соответственно:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: stop)</span>
<span class="c1">#1-&gt;irb#1 on main (#&lt;Thread:0x007fcb819b7bf8&gt;: stop)</span>
<span class="c1">#2-&gt;irb#2 on main (#&lt;Thread:0x007fcb81319238&gt;: running) </span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">003</span> <span class="o">&gt;</span> <span class="n">fg</span> <span class="mi">1</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;IRB::Irb: @context=#&lt;IRB::Context:0x007fcb819b7a40&gt;, @signal_status=:IN_EVAL, @scanner=#&lt;RubyLex:0x007fcb819b74c8&gt;&gt; </span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">00</span><span class="mi">9</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: stop)</span>
<span class="c1">#1-&gt;irb#1 on main (#&lt;Thread:0x007fcb819b7bf8&gt;: running)</span>
<span class="c1">#2-&gt;irb#2 on main (#&lt;Thread:0x007fcb81319238&gt;: stop) </span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">010</span> <span class="o">&gt;</span> <span class="n">kill</span> <span class="mi">2</span>
 <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span> 
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">011</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: stop)</span>
<span class="c1">#1-&gt;irb#1 on main (#&lt;Thread:0x007fcb819b7bf8&gt;: running) </span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">012</span> <span class="o">&gt;</span> <span class="n">kill</span> <span class="mi">1</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;IRB::Irb: @context=#&lt;IRB::Context:0x007fcb8185b2c8&gt;, @signal_status=:IN_EVAL, @scanner=#&lt;RubyLex:0x007fcb8110d5e8&gt;&gt; </span>
<span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p247</span> <span class="p">:</span><span class="mo">014</span> <span class="o">&gt;</span> <span class="n">jobs</span>
 <span class="o">=&gt;</span> <span class="c1">#0-&gt;irb on main (#&lt;Thread:0x007fcb810bcda0&gt;: running)</span></code></pre></div>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/01/15/ruby-and-predefined-global-variables/">
        Ruby и special/predefined variables
      </a>
    </h1>

    <span class="post-date">15 Jan 2014</span>

    <p>Не так давно я обнаружил интересный пример в одной замечательной книге. С этого примера, я бы и хотел начать наш разговор.</p>

<p>Выглядел примерно так:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/irb/</span>
<span class="nb">puts</span> <span class="vg">$&amp;</span>
<span class="c1">#=&gt; &quot;irb&quot;</span></code></pre></div>

<p>Так как до этого я не часто встречался с подобными “глобальными” переменными, пример заинтересовал меня и захотелось выяснить, что же это за переменные.
Первым делом, я решил узнать, как они называются и где их можно найти. Спустя несколько минут, стало ясно, что это так называемые “special variables”. Не долго думая и открыв google, просмотрев пару тройку результатов, стало ясно, что кроме списка этих переменных ничего особо нет. Это не сильно меня обрадовало и стало понятно, что пришло время открыть репозитарий ruby и начать искать в нем. Так же мне очень помогла одна небезизвестная <a href="http://patshaughnessy.net/ruby-under-a-microscope">книга</a>.
Как оказалось, ruby создает несколько специальных переменных, в зависимости от откружения, в котором запускаются программы, или в зависимости от действий, которые были выполены ранее. Кстати, это не совсем глобальные перменные, в чем легко можно убедиться, рассмотрев простой пример:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">test</span>
  <span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/test/</span>
  <span class="nb">puts</span> <span class="s2">&quot;$&amp; in test method </span><span class="si">#{</span><span class="vg">$&amp;</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/irb/</span>
<span class="nb">puts</span> <span class="s2">&quot;$&amp; in main </span><span class="si">#{</span><span class="vg">$&amp;</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="c1">#=&gt; &quot;irb&quot;</span>

<span class="nb">test</span>
<span class="c1">#=&gt; &quot;test&quot;</span></code></pre></div>

<p>Как видно из примера, в каждом scope (main и метода), “глобальная” переменная отличается. Любой адекватный человек спросит: как такое, тысяча чертей, возможно? На самом деле все довольно просто, но, для полного понимания, начать придется с основ. Как многие знают, начиная с верисии 1.9 в ruby была добавлена виртуальная машина или YARV или же <a href="http://atdot.net/yarv/">yet another ruby virtual machine</a>, называйте как хотите, суть одна и та же. Смысл в том, что каждый раз, при запуске, YARV так же создает особый стек, для локальных переменных. В этом стеке указываются абсолютно все локальные переменные, свои для каждого scope. Разделение scope-ов происходит с помощью специальной точки или указателя - environment point (далее EP). Так же, в стеке, перед каждой EP, создается специальная переменная svar, которая как раз и указывает на таблицу специальных символов. Именно из-за этого для каждого scope могут быть свои значения специальных символов, что мы видели в примере выше.
Но самое интересное, что у обычного блока и у места, где он будет вызван, scope одинаковый, в чем можно легко убедиться благодаря такому примеру:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/irb/</span>

<span class="mi">1</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
  <span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/test/</span>
  <span class="nb">puts</span> <span class="s2">&quot;$&amp; in block </span><span class="si">#{</span><span class="vg">$&amp;</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;$&amp; in main </span><span class="si">#{</span><span class="vg">$&amp;</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="o">&gt;</span> <span class="n">ruby</span> <span class="nb">test</span><span class="o">.</span><span class="n">rb</span>
<span class="o">&gt;&gt;</span> <span class="s2">&quot;$&amp; in block test&quot;</span>
<span class="o">&gt;&gt;</span> <span class="s2">&quot;$&amp; in block test&quot;</span>
<span class="o">&gt;&gt;</span> <span class="s2">&quot;$&amp; in main test&quot;</span></code></pre></div>

<p>На самом деле это логичное поведение, ибо замыкания никто не отменял.
Как я уже говорил, таких переменных <a href="http://readruby.io/globals">много</a>, но расскажу я о самых интересных(естественно для себя):</p>

<hr />

<h5 id="section">$&amp;</h5>
<p>Переменная, с которой начался наш рассказ. Хранит, как вы уже догадались, результат последнего совпадения регулярного выражения.</p>

<h5 id="section-1">$1 $2 $3 …</h5>
<p>Думаю, многим знакомая похожая переменная из регулярных выражений. Хотя, кого я обманываю? Это та же самая перменная, которая хранит совпадения из скобок:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/(irb)/</span>
<span class="nb">puts</span> <span class="vg">$1</span>
<span class="c1">#=&gt; &quot;irb&quot;</span></code></pre></div>

<h5 id="section-2">$~</h5>
<p>Содержит объект класса MatchData, соответствующий последнему совпадению.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/(irb)/</span>
<span class="nb">puts</span> <span class="vg">$~</span>
<span class="c1">#=&gt; #&lt;MatchData &quot;irb&quot; 1:&quot;irb&quot;&gt;</span>
<span class="nb">puts</span> <span class="vg">$~</span><span class="o">.</span><span class="n">to_s</span>
<span class="c1">#=&gt; &quot;irb&quot;</span>
<span class="nb">puts</span> <span class="vg">$~</span><span class="o">.</span><span class="n">to_a</span>
<span class="c1">#=&gt; [&quot;irb&quot;, &#39;irb&#39;]</span></code></pre></div>

<h5 id="section-3">$+</h5>
<p>Содержит значение последней круглой скобки из последнего совпадения:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/irb/</span>
<span class="nb">puts</span> <span class="vg">$~</span>
<span class="c1">#=&gt; #&lt;MatchData &quot;irb&quot; 1:&quot;irb&quot;&gt;</span>
<span class="nb">puts</span> <span class="vg">$+</span>
<span class="c1">#=&gt; nil</span>
<span class="s2">&quot;test in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/(test) (in) (irb)/</span>
<span class="nb">puts</span> <span class="vg">$~</span>
<span class="c1">#=&gt; #&lt;MatchData &quot;test in irb&quot; 1:&quot;test&quot; 2:&quot;in&quot; 3:&quot;irb&quot;&gt;</span>
<span class="nb">puts</span> <span class="vg">$+</span>
<span class="c1">#=&gt; &quot;irb&quot;</span></code></pre></div>

<h5 id="section-4">$`</h5>
<p>Содержит все то, что не совпало в последнем регулярном выражении:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;test string in irb&quot;</span><span class="o">.</span><span class="n">match</span> <span class="sr">/irb/</span>
<span class="nb">puts</span> <span class="vg">$`</span>
<span class="c1">#=&gt; &quot;test string in&quot;</span></code></pre></div>

<h5 id="section-5">$!</h5>
<p>Содержит последнее вызванное исключение:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span> <span class="k">rescue</span> <span class="vg">$!</span>
<span class="c1">#=&gt; #&lt;ZeroDivisionError: divided by 0&gt;</span></code></pre></div>

<h5 id="section-6">$@</h5>
<p>Ну а эта переменная содержит массив со всеми trace stack-ами из последнего исключения:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span> <span class="k">rescue</span> <span class="vg">$@</span>
<span class="c1">#=&gt; [&quot;&lt;main&gt;:4:in `/&#39;&quot;, &quot;&lt;main&gt;:4:in `/&#39;&quot;, &quot;(irb):98:in `irb_binding&#39;&quot;, ... ]</span></code></pre></div>

<h5 id="section-7">$*</h5>
<p>Эта переменная равносильна переменной ARGV, думаю этим все сказанно.</p>

<h5 id="section-8">$$</h5>
<p>Переменная возвращает номер процесса, под которым выполняется скрипт.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="vg">$$</span>
<span class="c1">#=&gt; 33630</span>
<span class="nb">puts</span> <span class="sb">`ps aux | grep irb`</span>
<span class="c1">#=&gt; anton           33630   0.0  0.3  2470520  24084 s008  S+    2Jan14   0:01.24 irb</span></code></pre></div>

<p>.</p>

<hr />

<p>Так где же определены эти переменные в исходном коде ruby? Как оказалось, все не так сложно, как кажется. Определенны эти переменные в файле <a href="https://github.com/ruby/ruby/blob/v2_1_0/parse.y#L7950">parse.y</a> примерно на 7950-той строке (да да, файл не очень большой, всего 11.5к строк кода). Для тех, кто не в курсе, parse.y - грамматический файл интерпритатора, благодаря которому происходит разбиение написанного вами кода на токены (лексемы/указатели), которые в последующем преобразуются в AST структуру, а затем в YARV структуру, ну а дальше в машинный код, который в последующем и будет выполняется.
Как не трудно заметить, case функция ищет совпадение символа “$” и специальных символов (блок case), после чего передает их функции set_yylval_name:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">7965</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;~&#39;</span><span class="o">:</span>                <span class="cm">/* $~: match-data */</span>
<span class="mi">7966</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>                <span class="cm">/* $*: argv */</span>
<span class="mi">7967</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;$&#39;</span><span class="o">:</span>                <span class="cm">/* $$: pid */</span>
<span class="mi">7968</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;?&#39;</span><span class="o">:</span>                <span class="cm">/* $?: last status */</span>
<span class="mi">7969</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;!&#39;</span><span class="o">:</span>                <span class="cm">/* $!: error string */</span>
<span class="mi">7970</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;@&#39;</span><span class="o">:</span>                <span class="cm">/* $@: error position */</span>
<span class="mi">7971</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>                <span class="cm">/* $/: input record separator */</span>
<span class="mi">7972</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;\\&#39;</span><span class="o">:</span>               <span class="cm">/* $\: output record separator */</span>
<span class="mi">7973</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;;&#39;</span><span class="o">:</span>                <span class="cm">/* $;: field separator */</span>
<span class="mi">7974</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;,&#39;</span><span class="o">:</span>                <span class="cm">/* $,: output field separator */</span>
<span class="mi">7975</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;.&#39;</span><span class="o">:</span>                <span class="cm">/* $.: last read line number */</span>
<span class="mi">7976</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;=&#39;</span><span class="o">:</span>                <span class="cm">/* $=: ignorecase */</span>
<span class="mi">7977</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;:&#39;</span><span class="o">:</span>                <span class="cm">/* $:: load path */</span>
<span class="mi">7978</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;&lt;&#39;</span><span class="o">:</span>                <span class="cm">/* $&lt;: reading filename */</span>
<span class="mi">7979</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;&gt;&#39;</span><span class="o">:</span>                <span class="cm">/* $&gt;: default output handle */</span>
<span class="mi">7980</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;\&quot;&#39;</span><span class="o">:</span>                <span class="cm">/* $&quot;: already loaded files */</span>
<span class="mi">7981</span><span class="o">:</span>   <span class="n">tokadd</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">);</span>
<span class="mi">7982</span><span class="o">:</span>   <span class="n">tokadd</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="mi">7983</span><span class="o">:</span>   <span class="k">goto</span> <span class="n">gvar</span><span class="p">;</span>

<span class="o">-------</span>

<span class="mi">7997</span><span class="o">:</span> <span class="nl">gvar</span><span class="p">:</span>
<span class="mi">7998</span><span class="o">:</span> <span class="n">set_yylval_name</span><span class="p">(</span><span class="n">rb_intern3</span><span class="p">(</span><span class="n">tok</span><span class="p">(),</span> <span class="n">tokidx</span><span class="p">,</span> <span class="n">current_enc</span><span class="p">));</span>
<span class="mi">7999</span><span class="o">:</span> <span class="k">return</span> <span class="n">tGVAR</span></code></pre></div>

<p>И в завершение, следует упомянуть особый файл - <a href="https://github.com/ruby/ruby/blob/v2_1_0/lib/English.rb">English.rb</a>, в котором прописаны алиасы для специальных переменных, благодаря чему можно использовать данные переменные намного понятнее, нежели чем использование $$, $&amp; и так далее:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">&quot;waterbuffalo&quot;</span> <span class="o">=~</span> <span class="sr">/buff/</span>
<span class="nb">print</span> <span class="vg">$&quot;</span><span class="p">,</span> <span class="vg">$&#39;</span><span class="p">,</span> <span class="vg">$$</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="c1"># With English:</span>

<span class="nb">require</span> <span class="s2">&quot;English&quot;</span>

<span class="s2">&quot;waterbuffalo&quot;</span> <span class="o">=~</span> <span class="sr">/buff/</span>
<span class="nb">print</span> <span class="vg">$LOADED_FEATURES</span><span class="p">,</span> <span class="vg">$POSTMATCH</span><span class="p">,</span> <span class="vg">$PID</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span></code></pre></div>


  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
